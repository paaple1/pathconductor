<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Conductor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Make canvas follow parent element's size */
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
        }
        #main-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #canvas-container {
            flex-grow: 1; /* Allow container to use all available space */
            position: relative;
        }
        canvas {
            display: block;
            background-color: #2d3748; /* Dark gray background */
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">

    <div id="main-container">
        <!-- Header and description -->
        <header class="p-4 bg-gray-800 shadow-md z-10 text-center">
            <h1 class="text-2xl font-bold">Path Conductor</h1>
            <p id="status-message" class="text-gray-300 mt-2">Usage: 1. Click start point → 2. Click curve apex → 3. Click end point</p>
        </header>

        <!-- Canvas container -->
        <div id="canvas-container">
            <canvas id="drawingCanvas"></canvas>
        </div>

        <!-- Control buttons -->
        <footer class="p-4 bg-gray-800 shadow-md z-10 flex justify-center items-center gap-4">
            <button id="clear-button" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
                Clear All
            </button>
             <button id="undo-button" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
                Undo
            </button>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const clearButton = document.getElementById('clear-button');
        const undoButton = document.getElementById('undo-button');
        
        const gridSize = 25;

        let points = []; 
        let curves = []; 
        let mousePos = { x: 0, y: 0 };

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            draw(); 
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        function getSnappedCoords(x, y) {
            const snappedX = Math.round(x / gridSize) * gridSize;
            const snappedY = Math.round(y / gridSize) * gridSize;
            return { x: snappedX, y: snappedY };
        }

        function getProjectedPointOnLine(point, lineP1, lineP2) {
            const L2 = Math.pow(lineP2.x - lineP1.x, 2) + Math.pow(lineP2.y - lineP1.y, 2);
            if (L2 === 0) return { ...lineP1 };

            const t = ((point.x - lineP1.x) * (lineP2.x - lineP1.x) + (point.y - lineP1.y) * (lineP2.y - lineP1.y)) / L2;
            
            const projectedX = lineP1.x + t * (lineP2.x - lineP1.x);
            const projectedY = lineP1.y + t * (lineP2.y - lineP1.y);
            
            return { x: projectedX, y: projectedY };
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawGrid(); 
            
            ctx.strokeStyle = '#f7fafc';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            curves.forEach(curve => {
                ctx.beginPath();
                ctx.moveTo(curve.p0.x, curve.p0.y);
                ctx.quadraticCurveTo(curve.p1.x, curve.p1.y, curve.p2.x, curve.p2.y);
                ctx.stroke();
            });

            ctx.fillStyle = '#f6e05e';
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fill();
            });

            if (points.length > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);

                if (points.length === 1) {
                    if (curves.length > 0) {
                        const lastCurve = curves[curves.length - 1];
                        const p1 = lastCurve.p1;
                        const p2 = lastCurve.p2;
                        const direction = { x: p2.x - p1.x, y: p2.y - p1.y };

                        if (direction.x !== 0 || direction.y !== 0) {
                            ctx.save();
                            ctx.strokeStyle = 'rgba(255, 255, 100, 0.7)'; 
                            ctx.lineWidth = 1.5;
                            ctx.setLineDash([8, 8]);

                            const start = p2;
                            const scale = Math.max(canvas.width, canvas.height) * 2;
                            const lineEnd1 = { x: start.x + direction.x * scale, y: start.y + direction.y * scale };
                            const lineStart1 = { x: start.x - direction.x * scale, y: start.y - direction.y * scale };
                            
                            ctx.beginPath();
                            ctx.moveTo(lineStart1.x, lineStart1.y);
                            ctx.lineTo(lineEnd1.x, lineEnd1.y);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.stroke();
                }
                
                if (points.length === 2) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                    ctx.lineTo(mousePos.x, mousePos.y); 
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    ctx.strokeStyle = '#63b3ed';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.quadraticCurveTo(points[1].x, points[1].y, mousePos.x, mousePos.y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            let pointToPush = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            if (points.length === 1 && curves.length > 0) {
                const lastCurve = curves[curves.length - 1];
                const p1_prev = lastCurve.p1;
                const p2_prev = lastCurve.p2;
                const direction = { x: p2_prev.x - p1_prev.x, y: p2_prev.y - p1_prev.y };

                if (direction.x !== 0 || direction.y !== 0) {
                    const lineStart = p2_prev;
                    const lineEnd = { x: p2_prev.x + direction.x, y: p2_prev.y + direction.y };
                    pointToPush = getProjectedPointOnLine(pointToPush, lineStart, lineEnd);
                }
            }
            
            const snappedPoint = getSnappedCoords(pointToPush.x, pointToPush.y);

            const lastPoint = points.length > 0 ? points[points.length - 1] : (curves.length > 0 ? curves[curves.length-1].p2 : null);
             if (lastPoint && lastPoint.x === snappedPoint.x && lastPoint.y === snappedPoint.y) {
                return; 
            }

            points.push(snappedPoint);

            // --- 【MODIFIED】Connection integrity adjustment ---
            if (points.length === 3) {
                const newCurve = { p0: points[0], p1: points[1], p2: points[2] };

                // If there are existing curves, ensure the new curve's start point
                // perfectly matches the last curve's end point.
                if (curves.length > 0) {
                    const lastCurve = curves[curves.length - 1];
                    newCurve.p0 = lastCurve.p2; // Explicitly enforce connection
                }

                curves.push(newCurve);
                points = [newCurve.p2]; // Start the next curve from the new end point
            }
            updateStatus();
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            let currentPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            if (points.length === 1 && curves.length > 0) {
                const lastCurve = curves[curves.length - 1];
                const p1_prev = lastCurve.p1;
                const p2_prev = lastCurve.p2;
                const direction = { x: p2_prev.x - p1_prev.x, y: p2_prev.y - p1_prev.y };

                if (direction.x !== 0 || direction.y !== 0) {
                    const lineStart = p2_prev;
                    const lineEnd = { x: p2_prev.x + direction.x, y: p2_prev.y + direction.y };
                    currentPos = getProjectedPointOnLine(currentPos, lineStart, lineEnd);
                }
            }
            
            mousePos = getSnappedCoords(currentPos.x, currentPos.y);
            
            if (points.length > 0) {
                requestAnimationFrame(draw);
            }
        });

        clearButton.addEventListener('click', () => {
            points = [];
            curves = [];
            updateStatus();
            draw();
        });
        
        undoButton.addEventListener('click', () => {
            if (points.length > 1) {
                points.pop();
            } else if (curves.length > 0) {
                const lastCurve = curves.pop();
                points = [lastCurve.p0];
            } else {
                 points = [];
            }
            updateStatus();
            draw();
        });

        // --- 【MODIFIED】Update status messages to English ---
        function updateStatus() {
            switch (points.length) {
                case 0:
                    statusMessage.textContent = 'Click to place the starting point.';
                    break;
                case 1:
                    if (curves.length > 0) {
                        statusMessage.textContent = "Click along the guide line to place the curve's apex.";
                    } else {
                        statusMessage.textContent = "Click to place the curve's apex (control point).";
                    }
                    break;
                case 2:
                    statusMessage.textContent = "Click to place the curve's end point.";
                    break;
            }
        }
        
        updateStatus();
    </script>
</body>
</html>
