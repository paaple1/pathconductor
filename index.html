<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Conductor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
        #main-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding-bottom: 80px; 
            box-sizing: border-box;
        }
        #canvas-container {
            flex-grow: 1; 
            position: relative;
        }
        canvas {
            display: block;
            background-color: #2d3748;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">

    <div id="main-container">
        <!-- Header and description -->
        <header class="p-4 bg-gray-800 shadow-md z-10 text-center">
            <h1 class="text-2xl font-bold">Path Conductor</h1>
            <p id="status-message" class="text-gray-300 mt-2">Usage: 1. Click start point → 2. Click curve apex → 3. Click end point</p>
        </header>

        <!-- Canvas container -->
        <div id="canvas-container">
            <canvas id="drawingCanvas"></canvas>
        </div>
    </div>

    <!-- Control buttons -->
    <footer class="fixed bottom-0 w-full p-4 bg-gray-800 shadow-md z-20 flex justify-center items-center flex-wrap gap-4">
        <button id="connect-button" class="bg-green-700 hover:bg-green-800 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
            Connect Start & End
        </button>
        <button id="complete-button" class="bg-blue-700 hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
            Complete
        </button>
        <button id="undo-button" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
            Undo
        </button>
        <button id="clear-button" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
            Clear All
        </button>
    </footer>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const clearButton = document.getElementById('clear-button');
        const undoButton = document.getElementById('undo-button');
        const completeButton = document.getElementById('complete-button');
        const connectButton = document.getElementById('connect-button');
        
        let points = []; 
        let curves = []; 
        let mousePos = { x: 0, y: 0 };
        
        let isComplete = false;
        let history = []; // To store actions for robust undo

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw(); 
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function getProjectedPointOnLine(point, lineP1, lineP2) {
            const L2 = Math.pow(lineP2.x - lineP1.x, 2) + Math.pow(lineP2.y - lineP1.y, 2);
            if (L2 === 0) return { ...lineP1 };

            const t = ((point.x - lineP1.x) * (lineP2.x - lineP1.x) + (point.y - lineP1.y) * (lineP2.y - lineP1.y)) / L2;
            
            return { x: lineP1.x + t * (lineP2.x - lineP1.x), y: lineP1.y + t * (lineP2.y - lineP1.y) };
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#f7fafc';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            curves.forEach(curve => {
                ctx.beginPath();
                ctx.moveTo(curve.p0.x, curve.p0.y);
                ctx.quadraticCurveTo(curve.p1.x, curve.p1.y, curve.p2.x, curve.p2.y);
                ctx.stroke();
            });

            // Do not show preview points or lines if the track is complete
            if (isComplete) return;

            ctx.fillStyle = '#f6e05e';
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fill();
            });

            if (points.length > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);

                if (points.length === 1) {
                    if (curves.length > 0) {
                        const lastCurve = curves[curves.length - 1];
                        const direction = { x: lastCurve.p2.x - lastCurve.p1.x, y: lastCurve.p2.y - lastCurve.p1.y };

                        if (direction.x !== 0 || direction.y !== 0) {
                            ctx.save();
                            ctx.strokeStyle = 'rgba(255, 255, 100, 0.7)'; 
                            ctx.lineWidth = 1.5;
                            ctx.setLineDash([8, 8]);
                            const start = lastCurve.p2;
                            const scale = Math.max(canvas.width, canvas.height) * 2;
                            const lineEnd1 = { x: start.x + direction.x * scale, y: start.y + direction.y * scale };
                            const lineStart1 = { x: start.x - direction.x * scale, y: start.y - direction.y * scale };
                            ctx.beginPath();
                            ctx.moveTo(lineStart1.x, lineStart1.y);
                            ctx.lineTo(lineEnd1.x, lineEnd1.y);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.stroke();
                }
                
                if (points.length === 2) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                    ctx.lineTo(mousePos.x, mousePos.y); 
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    ctx.strokeStyle = '#63b3ed';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.quadraticCurveTo(points[1].x, points[1].y, mousePos.x, mousePos.y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            if (isComplete) return; // Do not add points if track is complete

            const rect = canvas.getBoundingClientRect();
            let pointToPush = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            if (points.length === 1 && curves.length > 0) {
                const lastCurve = curves[curves.length - 1];
                const direction = { x: lastCurve.p2.x - lastCurve.p1.x, y: lastCurve.p2.y - lastCurve.p1.y };

                if (direction.x !== 0 || direction.y !== 0) {
                    const lineStart = lastCurve.p2;
                    const lineEnd = { x: lastCurve.p2.x + direction.x, y: lastCurve.p2.y + direction.y };
                    pointToPush = getProjectedPointOnLine(pointToPush, lineStart, lineEnd);
                }
            }
            
            points.push(pointToPush);

            if (points.length === 3) {
                const newCurve = { p0: points[0], p1: points[1], p2: points[2] };
                if (curves.length > 0) {
                    newCurve.p0 = curves[curves.length - 1].p2;
                }
                curves.push(newCurve);
                history.push({ type: 'add_curve', curve: newCurve });
                points = [newCurve.p2];
            }
            updateStatus();
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isComplete) return;

            const rect = canvas.getBoundingClientRect();
            let currentPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            if (points.length === 1 && curves.length > 0) {
                const lastCurve = curves[curves.length - 1];
                const direction = { x: lastCurve.p2.x - lastCurve.p1.x, y: lastCurve.p2.y - lastCurve.p1.y };

                if (direction.x !== 0 || direction.y !== 0) {
                    const lineStart = lastCurve.p2;
                    const lineEnd = { x: lastCurve.p2.x + direction.x, y: lastCurve.p2.y + direction.y };
                    currentPos = getProjectedPointOnLine(currentPos, lineStart, lineEnd);
                }
            }
            mousePos = currentPos;
            requestAnimationFrame(draw);
        });

        clearButton.addEventListener('click', () => {
            points = [];
            curves = [];
            history = [];
            isComplete = false;
            updateStatus();
            draw();
        });
        
        completeButton.addEventListener('click', () => {
            if (isComplete || curves.length === 0) return;
            history.push({ type: 'complete' });
            isComplete = true;
            points = [];
            updateStatus();
            draw();
        });

        connectButton.addEventListener('click', () => {
            if (isComplete || curves.length < 1) return;

            const lastCurve = curves[curves.length - 1];
            const startPoint = curves[0].p0;
            const endPoint = lastCurve.p2;

            // Create a control point that smoothly exits the last curve
            const controlPoint = {
                x: endPoint.x + (endPoint.x - lastCurve.p1.x),
                y: endPoint.y + (endPoint.y - lastCurve.p1.y)
            };

            const closingCurve = { p0: endPoint, p1: controlPoint, p2: startPoint };
            curves.push(closingCurve);
            history.push({ type: 'connect', curve: closingCurve });

            isComplete = true;
            points = [];
            updateStatus();
            draw();
        });

        undoButton.addEventListener('click', () => {
            const lastAction = history.pop();
            if (!lastAction) return;

            if (lastAction.type === 'add_curve') {
                curves.pop();
                if (curves.length > 0) {
                    points = [curves[curves.length - 1].p2];
                } else {
                    points = [];
                }
            } else if (lastAction.type === 'complete') {
                isComplete = false;
                if (curves.length > 0) {
                    points = [curves[curves.length - 1].p2];
                }
            } else if (lastAction.type === 'connect') {
                curves.pop();
                isComplete = false;
                if (curves.length > 0) {
                    points = [curves[curves.length - 1].p2];
                }
            }
            
            updateStatus();
            draw();
        });

        function updateStatus() {
            if (isComplete) {
                statusMessage.textContent = 'Track completed. You can undo to continue editing.';
                return;
            }

            switch (points.length) {
                case 0:
                    statusMessage.textContent = 'Click to place the starting point.';
                    break;
                case 1:
                    if (curves.length > 0) {
                        statusMessage.textContent = "Click along the guide line to place the curve's apex.";
                    } else {
                        statusMessage.textContent = "Click to place the curve's apex (control point).";
                    }
                    break;
                case 2:
                    statusMessage.textContent = "Click anywhere to place the curve's end point.";
                    break;
            }
        }
        
        updateStatus();
    </script>
</body>
</html>
