<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Conductor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
        }
        #main-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            /* Add padding to the bottom to prevent the fixed footer from overlapping the canvas content */
            padding-bottom: 80px; 
            box-sizing: border-box;
        }
        #canvas-container {
            flex-grow: 1; 
            position: relative;
        }
        canvas {
            display: block;
            background-color: #2d3748; /* Dark gray background */
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">

    <div id="main-container">
        <!-- Header and description -->
        <header class="p-4 bg-gray-800 shadow-md z-10 text-center">
            <h1 class="text-2xl font-bold">Path Conductor</h1>
            <p id="status-message" class="text-gray-300 mt-2">Usage: 1. Click start point → 2. Click curve apex → 3. Click end point</p>
        </header>

        <!-- Canvas container -->
        <div id="canvas-container">
            <canvas id="drawingCanvas"></canvas>
        </div>
    </div>

    <!-- Control buttons (Now fixed to the bottom) -->
    <footer class="fixed bottom-0 w-full p-4 bg-gray-800 shadow-md z-20 flex justify-center items-center gap-4">
        <button id="clear-button" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
            Clear All
        </button>
         <button id="undo-button" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200">
            Undo
        </button>
    </footer>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const statusMessage = document.getElementById('status-message');
        const clearButton = document.getElementById('clear-button');
        const undoButton = document.getElementById('undo-button');
        
        let points = []; 
        let curves = []; 
        let mousePos = { x: 0, y: 0 };

        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw(); 
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function getProjectedPointOnLine(point, lineP1, lineP2) {
            const L2 = Math.pow(lineP2.x - lineP1.x, 2) + Math.pow(lineP2.y - lineP1.y, 2);
            if (L2 === 0) return { ...lineP1 };

            const t = ((point.x - lineP1.x) * (lineP2.x - lineP1.x) + (point.y - lineP1.y) * (lineP2.y - lineP1.y)) / L2;
            
            const projectedX = lineP1.x + t * (lineP2.x - lineP1.x);
            const projectedY = lineP1.y + t * (lineP2.y - lineP1.y);
            
            return { x: projectedX, y: projectedY };
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#f7fafc';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            curves.forEach(curve => {
                ctx.beginPath();
                ctx.moveTo(curve.p0.x, curve.p0.y);
                ctx.quadraticCurveTo(curve.p1.x, curve.p1.y, curve.p2.x, curve.p2.y);
                ctx.stroke();
            });

            ctx.fillStyle = '#f6e05e';
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fill();
            });

            if (points.length > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);

                if (points.length === 1) {
                    if (curves.length > 0) {
                        const lastCurve = curves[curves.length - 1];
                        const p1 = lastCurve.p1;
                        const p2 = lastCurve.p2;
                        const direction = { x: p2.x - p1.x, y: p2.y - p1.y };

                        if (direction.x !== 0 || direction.y !== 0) {
                            ctx.save();
                            ctx.strokeStyle = 'rgba(255, 255, 100, 0.7)'; 
                            ctx.lineWidth = 1.5;
                            ctx.setLineDash([8, 8]);

                            const start = p2;
                            const scale = Math.max(canvas.width, canvas.height) * 2;
                            const lineEnd1 = { x: start.x + direction.x * scale, y: start.y + direction.y * scale };
                            const lineStart1 = { x: start.x - direction.x * scale, y: start.y - direction.y * scale };
                            
                            ctx.beginPath();
                            ctx.moveTo(lineStart1.x, lineStart1.y);
                            ctx.lineTo(lineEnd1.x, lineEnd1.y);
                            ctx.stroke();
                            ctx.restore();
                        }
                    }
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(mousePos.x, mousePos.y);
                    ctx.stroke();
                }
                
                if (points.length === 2) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                    ctx.lineTo(mousePos.x, mousePos.y); 
                    ctx.stroke();
                    
                    ctx.setLineDash([]);
                    ctx.strokeStyle = '#63b3ed';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.quadraticCurveTo(points[1].x, points[1].y, mousePos.x, mousePos.y);
                    ctx.stroke();
                }
                ctx.setLineDash([]);
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            let pointToPush = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            // When placing the control point (p1) of a subsequent curve, project it onto the guideline.
            if (points.length === 1 && curves.length > 0) {
                const lastCurve = curves[curves.length - 1];
                const p1_prev = lastCurve.p1;
                const p2_prev = lastCurve.p2;
                const direction = { x: p2_prev.x - p1_prev.x, y: p2_prev.y - p1_prev.y };

                if (direction.x !== 0 || direction.y !== 0) {
                    const lineStart = p2_prev;
                    const lineEnd = { x: p2_prev.x + direction.x, y: p2_prev.y + direction.y };
                    pointToPush = getProjectedPointOnLine(pointToPush, lineStart, lineEnd);
                }
            }
            
            const lastPoint = points.length > 0 ? points[points.length - 1] : (curves.length > 0 ? curves[curves.length-1].p2 : null);
            if (lastPoint && lastPoint.x === pointToPush.x && lastPoint.y === pointToPush.y) {
                return; 
            }

            points.push(pointToPush);

            if (points.length === 3) {
                const newCurve = { p0: points[0], p1: points[1], p2: points[2] };

                if (curves.length > 0) {
                    const lastCurve = curves[curves.length - 1];
                    newCurve.p0 = lastCurve.p2; 
                }

                curves.push(newCurve);
                points = [newCurve.p2];
            }
            updateStatus();
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            let currentPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };

            // When previewing the control point, project the cursor onto the guideline.
            if (points.length === 1 && curves.length > 0) {
                const lastCurve = curves[curves.length - 1];
                const p1_prev = lastCurve.p1;
                const p2_prev = lastCurve.p2;
                const direction = { x: p2_prev.x - p1_prev.x, y: p2_prev.y - p1_prev.y };

                if (direction.x !== 0 || direction.y !== 0) {
                    const lineStart = p2_prev;
                    const lineEnd = { x: p2_prev.x + direction.x, y: p2_prev.y + direction.y };
                    currentPos = getProjectedPointOnLine(currentPos, lineStart, lineEnd);
                }
            }
            
            mousePos = currentPos;
            
            if (points.length > 0) {
                requestAnimationFrame(draw);
            }
        });

        clearButton.addEventListener('click', () => {
            points = [];
            curves = [];
            updateStatus();
            draw();
        });
        
        undoButton.addEventListener('click', () => {
            if (points.length > 1) {
                points.pop();
            } else if (curves.length > 0) {
                const lastCurve = curves.pop();
                points = [lastCurve.p0];
            } else {
                 points = [];
            }
            updateStatus();
            draw();
        });

        function updateStatus() {
            switch (points.length) {
                case 0:
                    statusMessage.textContent = 'Click to place the starting point.';
                    break;
                case 1:
                    if (curves.length > 0) {
                        statusMessage.textContent = "Click along the guide line to place the curve's apex.";
                    } else {
                        statusMessage.textContent = "Click to place the curve's apex (control point).";
                    }
                    break;
                case 2:
                    statusMessage.textContent = "Click anywhere to place the curve's end point.";
                    break;
            }
        }
        
        updateStatus();
    </script>
</body>
</html>
